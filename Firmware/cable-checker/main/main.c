#include "led_strip.h"
#include "button_gpio.h"
#include "esp_log.h"
#include "gpios.h"

#include "es8388.h"
#include "iot_button.h"
#include "led_strip_interface.h"
#include "driver/i2s_std.h"
#include "driver/i2s_types_legacy.h"
#include "hal/i2s_types.h"

typedef enum {
    MODE_PLAY,
    MODE_RECORD,
    MODE_BOTH
} Mode;

//MARK: Global variables
static Mode current_mode = MODE_BOTH;
static bool headphone_inserted = false;
i2s_chan_handle_t tx_handle;
i2s_chan_handle_t rx_handle;

//MARK: Setup functions
led_strip_handle_t setup_led(const int gpio, const int count) {
    /// LED strip common configuration
    led_strip_config_t strip_config = {
        .strip_gpio_num = gpio, // The GPIO that connected to the LED strip's data line
        .max_leds = count, // The number of LEDs in the strip,
        .led_model = LED_MODEL_WS2812, // LED strip model, it determines the bit timing
        .color_component_format = LED_STRIP_COLOR_COMPONENT_FMT_GRB, // The color component format is G-R-B
        .flags = {
            .invert_out = false, // don't invert the output signal
        }
    };

    /// RMT backend specific configuration
    led_strip_rmt_config_t rmt_config = {
        .clk_src = RMT_CLK_SRC_DEFAULT, // different clock source can lead to different power consumption
        .resolution_hz = 10 * 1000 * 1000, // RMT counter clock frequency: 10MHz
        .mem_block_symbols = 64, // the memory size of each RMT channel, in words (4 bytes)
        .flags = {
            .with_dma = false, // DMA feature is available on chips like ESP32-S3/P4
        }
    };

    /// Create the LED strip object
    led_strip_handle_t led_strip = NULL;
    ESP_ERROR_CHECK(led_strip_new_rmt_device(&strip_config, &rmt_config, &led_strip));
    return led_strip;
}

button_handle_t setup_button(const int gpio, const int active_level) {
    const button_config_t btn_cfg = {.long_press_time = 3000};
    const button_gpio_config_t btn_gpio_cfg = {
        .gpio_num = gpio,
        .active_level = active_level,
    };
    button_handle_t button = NULL;
    ESP_ERROR_CHECK(iot_button_new_gpio_device(&btn_cfg, &btn_gpio_cfg, &button));
    return button;
}

void setup_es8388_i2s() {
    i2s_std_slot_config_t slot_config = {
        .slot_mode = I2S_SLOT_MODE_MONO, /*!< Set mono or stereo mode with I2S_SLOT_MODE_MONO or I2S_SLOT_MODE_STEREO
                              *   In TX direction, mono means the written buffer contains only one slot data
                              *   and stereo means the written buffer contains both left and right data
                              */
    };

    i2s_std_gpio_config_t gpio_config = {
        .mclk = MCLK,
        .bclk = SCLK, /*!< BCK pin, input in slave role, output in master role */
        .ws = LRCK, /*!< WS pin, input in slave role, output in master role */
        .dout = ASDOUT, /*!< DATA pin, output */
        .din = DSDIN, /*!< DATA pin, input */
    };

    i2s_std_config_t i2s_config = {
        .slot_cfg = slot_config,
        /*!< Standard mode slot configuration, can be generated by macros I2S_STD_[mode]_SLOT_DEFAULT_CONFIG, [mode] can be replaced with PHILIPS/MSB/PCM */
        .gpio_cfg = gpio_config, /*!< Standard mode GPIO configuration, specified by user */
    };

    i2s_channel_init_std_mode(tx_handle, &i2s_config);
    i2s_channel_init_std_mode(rx_handle, &i2s_config);
    i2s_channel_enable(tx_handle);
    i2s_channel_enable(rx_handle);
}

void setup_es8388_i2c() {
    i2c_config_t i2c_config = {
        .mode = I2C_MODE_SLAVE, /*!< I2C mode */
        .sda_io_num = CDATA, /*!< GPIO number for I2C sda signal */
        .scl_io_num = CCLK, /*!< GPIO number for I2C scl signal */
    };

    i2c_param_config(I2C_NUM_0, &i2c_config);
    i2c_driver_install(I2C_NUM_0, i2c_config.mode, 0, 0, 0);
}

void setup_es8388_codec() {
    audio_hal_codec_i2s_iface_t i2s_iface = {
        .mode = AUDIO_HAL_MODE_SLAVE, /*!< audio codec chip mode */
        .fmt = AUDIO_HAL_I2S_NORMAL, /*!< I2S interface format */
        .samples = AUDIO_HAL_32K_SAMPLES, /*!< I2S interface samples per second */
        .bits = AUDIO_HAL_BIT_LENGTH_16BITS, /*!< i2s interface number of bits per sample */
    };

    audio_hal_codec_config_t config = {
        .adc_input = AUDIO_HAL_ADC_INPUT_LINE1, /*!< set adc channel */
        .dac_output = AUDIO_HAL_DAC_OUTPUT_LINE1, /*!< set dac channel */
        .codec_mode = AUDIO_HAL_CODEC_MODE_BOTH, /*!< select codec mode: adc, dac or both */
        .i2s_iface = i2s_iface, /*!< set I2S interface configuration */
    };
    es8388_init(&config);
}

//MARK: Callback functions
void select_mode_cb(void *arg, void *usr_data) {
    Mode new_mode = *(Mode *) usr_data;
    current_mode = new_mode;

    switch (current_mode) {
        case MODE_PLAY:
        //led_strip_set_pixel(led_strip, MODE_LED_INDEX, 255, 0, 0);
        case MODE_RECORD:
            //led_strip_set_pixel(led_strip, MODE_LED_INDEX, 0, 255, 0);
        default:
            //led_strip_set_pixel(led_strip, MODE_LED_INDEX, 0, 0, 255);

    }
}

void headphone_insert_cb(void *arg, void *usr_data) {
    ESP_LOGI("Headphone", "Inserted");
    headphone_inserted = true;
}

void headphone_remove_cb(void *arg, void *usr_data) {
    ESP_LOGI("Headphone", "Removed");
    headphone_inserted = false;
}

void encoder_hold_cb(void *arg, void *usr_data) {
    ESP_LOGI("Encoder", "Hold");
    // Handle encoder hold event
}

void encoder_click_cb(void *arg, void *usr_data) {
    ESP_LOGI("Encoder", "Clicked");
    // Handle encoder click event
}


void setup_SP3T() {
    button_handle_t switch_a = setup_button(SP3T_A, 0);
    static Mode mode_play = MODE_PLAY;
    iot_button_register_cb(switch_a, BUTTON_ACTIVE, NULL, select_mode_cb, &mode_play);

    button_handle_t switch_b = setup_button(SP3T_B, 0);
    static Mode mode_both = MODE_BOTH;
    iot_button_register_cb(switch_b, BUTTON_ACTIVE, NULL, select_mode_cb, &mode_both);

    button_handle_t switch_c = setup_button(SP3T_C, 0);
    static Mode mode_record = MODE_RECORD;
    iot_button_register_cb(switch_c, BUTTON_ACTIVE, NULL, select_mode_cb, &mode_record);
}

void setup_ring_shunt() {
    button_handle_t ring_shunt = setup_button(RSH, 1);
    iot_button_register_cb(ring_shunt, BUTTON_PRESS_DOWN, NULL, headphone_insert_cb, NULL);
    iot_button_register_cb(ring_shunt, BUTTON_PRESS_UP, NULL, headphone_remove_cb, NULL);
}

void setup_encoder_button() {
    button_handle_t encoder_button = setup_button(ROTARY_SW, 0);
    iot_button_register_cb(encoder_button, BUTTON_LONG_PRESS_START, NULL, encoder_hold_cb, NULL);
    iot_button_register_cb(encoder_button, BUTTON_SINGLE_CLICK, NULL, encoder_click_cb, NULL);
}

//MARK: Main
void app_main(void) {
    led_strip_handle_t led_strip = setup_led(LED_DIN, LED_COUNT);

    setup_ring_shunt();
    setup_encoder_button();
    setup_SP3T();

    while (true) {
        switch (current_mode) {
            case MODE_PLAY:
                printf("Current mode: PLAY");
            case MODE_RECORD:
                printf("Current mode: RECORD");
            default:
                printf("Current mode: BOTH");
        }
    }
}

/*
Maybe slide switch for selecting in/out/both
Flash leds when any input happens
Led show output
Reserve one led for mode

Input gain is managed by software

When headphones, use half led for output, half for Jack -> click to switch (half that changing flashes)

When headphones, start with volume low
In
Hold for 3 secs to start test
Display input
Flash green/yellow/red
Run for 5
Out
Hold for 3 secs to start test
Generate sine wave/white noise
Start with low volume, let user use encoder to turn up.
Hold for 3 secs to end
Both
Hold for 3 secs to start test
Run for 5
 */
